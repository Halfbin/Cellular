
#include "GLContext.hpp"

#include <Rk/exception.hpp>
#include <Rk/guard.hpp>

#include "MinWin.hpp"

#include <GL/glew.h>
#include <GL/wglew.h>

#include "GLError.hpp"

namespace Ce
{
  namespace
  {
    // Create a dummy window for extension-grabbing shenanigans
    HWND create_dummy_window ()
    {
      // Register class for dummy extension-grabbing window
      WNDCLASSEXW dummy_class = { };
      dummy_class.cbSize        = sizeof (dummy_class);
      dummy_class.hInstance     = GetModuleHandleW (nullptr);
      dummy_class.lpfnWndProc   = &DefWindowProcW;
      dummy_class.lpszClassName = L"Ce::GLContext dummy";
      RegisterClassExW (&dummy_class);

      // Create dummy window
      auto dummy_window = CreateWindowExW (
        0, dummy_class.lpszClassName, dummy_class.lpszClassName, 0,
        100, 100, 100, 100, 0, 0, GetModuleHandleW (0), 0
      );

      if (!dummy_window || iptr (dummy_window) == -1)
        throw Rk::win_error ("CreateWindowExW failed for dummy");

      return dummy_window;
    }

    // Bind context to dummy dc so extension-grabbing works
    HGLRC bind_dummy_context (HDC dummy_dc)
    {
      // Configure dummy window pixel format
      PIXELFORMATDESCRIPTOR dummy_pfd = { };
      dummy_pfd.nSize      = sizeof (dummy_pfd);
      dummy_pfd.nVersion   = 1;
      dummy_pfd.dwFlags    = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW;
      dummy_pfd.iPixelType = PFD_TYPE_RGBA;
      dummy_pfd.cColorBits = 24;
      dummy_pfd.cDepthBits = 16;
      dummy_pfd.iLayerType = PFD_MAIN_PLANE;

      int format = ChoosePixelFormat (dummy_dc, &dummy_pfd);
      if (!format) throw Rk::win_error ("ChoosePixelFormat failed for dummy");

      i32 ok = SetPixelFormat (dummy_dc, format, &dummy_pfd);
      if (!ok) throw Rk::win_error ("SetPixelFormat failed for dummy");

      // Create and bind dummy context
      auto dummy_rc = wglCreateContext (dummy_dc);
      if (!dummy_rc) throw std::runtime_error ("wglCreateContext failed for dummy");

      auto dummy_current_ok = wglMakeCurrent (dummy_dc, dummy_rc);
      if (!dummy_current_ok)
      {
        wglDeleteContext (dummy_rc);
        throw std::runtime_error ("wglMakeCurrent failed for dummy");
      }

      return dummy_rc;
    }

    // Newer wgl APIs for creating new-style contexts
    struct NewGLAPIs
    {
      PFNWGLCHOOSEPIXELFORMATARBPROC    wglChoosePixelFormat;
      PFNWGLCREATECONTEXTATTRIBSARBPROC wglCreateContextAttribs;
    };

    // Create and bind a new-style context to the dc
    HGLRC bind_context (HDC dc, const NewGLAPIs& apis)
    {
      const i32 pixel_format_int_attribs [] = {
        WGL_DRAW_TO_WINDOW_ARB, true,
        WGL_SUPPORT_OPENGL_ARB, true,
        WGL_ACCELERATION_ARB,   WGL_FULL_ACCELERATION_ARB,
        WGL_COLOR_BITS_ARB,     24,
        WGL_ALPHA_BITS_ARB,     8,
        WGL_DEPTH_BITS_ARB,     16,
        WGL_DOUBLE_BUFFER_ARB,  true,
        WGL_SAMPLE_BUFFERS_ARB, true,
        WGL_SAMPLES_ARB,        8,
        0, 0
      };

      u32 format_count;
      int format;
      auto ok = apis.wglChoosePixelFormat (dc, pixel_format_int_attribs, nullptr, 1, &format, &format_count);
      if (!ok || format_count == 0)
        throw std::runtime_error ("wglChoosePixelFormat failed");

      PIXELFORMATDESCRIPTOR dummy_pfd = { };
      ok = SetPixelFormat (dc, format, &dummy_pfd); // PFD pointer is irrelevant, but necessary.
      if (!ok) throw Rk::win_error ("SetPixelFormat failed for display");

      const int context_attribs [] = {
        WGL_CONTEXT_MAJOR_VERSION_ARB, 3,
        WGL_CONTEXT_MINOR_VERSION_ARB, 3,
        WGL_CONTEXT_PROFILE_MASK_ARB,  WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
      #ifndef NDEBUG
        WGL_CONTEXT_FLAGS_ARB,         WGL_CONTEXT_DEBUG_BIT_ARB,
      #endif
        0, 0
      };

      auto rc = apis.wglCreateContextAttribs (dc, 0, context_attribs);
      if (!rc) throw std::runtime_error ("wglCreateContextAttribsARB failed");

      ok = wglMakeCurrent (dc, rc);
      if (!ok)
      {
        wglDeleteContext (rc);
        throw std::runtime_error ("wglMakeCurrent failed for display");
      }

      return rc;
    }

    // Get pointer to wgl extension API
    template <typename Fn>
    void link_wgl (Fn& fn, const char* name)
    {
      fn = (Fn) wglGetProcAddress (name);
      if (!fn) throw std::runtime_error ("wglGetProcAddress failed");
    }

    // Configure OpenGL for real
    void opengl_setup ()
    {
      // Initialize GLEW.
      glewExperimental = true;
      auto glew_ok = glewInit ();
      if (glew_ok != GLEW_OK) throw std::runtime_error ("glewInit failed");
      glGetError (); // Ignore INVALID_ENUM sometimes generated by glewInit

      if (wglewIsSupported ("WGL_EXT_swap_control"))
      {
        PFNWGLSWAPINTERVALEXTPROC wglSwapInterval;
        link_wgl (wglSwapInterval, "wglSwapIntervalEXT");
        wglSwapInterval (1);
      }

      glEnable (GL_MULTISAMPLE);
      check_gl ("glEnable (GL_MULTISAMPLE) failed");
    }

  }

  struct GLContext::Impl
  {
    HWND  target;
    HDC   dc;
    HGLRC rc;

    Impl (HWND target);
    ~Impl ();

  };

  GLContext::Impl::Impl (HWND target) :
    target (target),
    dc     (0),
    rc     (0)
  {
    // Dummy window for grabbing new WGL apis
    auto dummy_window = create_dummy_window ();
    auto dummy_window_guard = Rk::guard (DestroyWindow, dummy_window);

    // Dummy context
    auto dummy_dc = GetDC (dummy_window);
    if (!dummy_dc) throw Rk::win_error ("GetDC failed for dummy");
    auto dummy_dc_guard = Rk::guard (ReleaseDC, dummy_window, dummy_dc);

    auto dummy_rc = bind_dummy_context (dummy_dc);
    auto dummy_rc_guard = Rk::guard (wglDeleteContext, dummy_rc);

    // Grab APIs
    NewGLAPIs apis;
    link_wgl (apis.wglChoosePixelFormat,    "wglChoosePixelFormatARB");
    link_wgl (apis.wglCreateContextAttribs, "wglCreateContextAttribsARB");

    // Real context
    dc = GetDC (target);
    if (!dc) throw Rk::win_error ("GetDC failed for display");
    auto dc_guard = Rk::guard (ReleaseDC, dummy_window, dummy_dc);

    rc = bind_context (dc, apis);
    auto rc_guard = Rk::guard (wglDeleteContext, rc);
    dummy_dc_guard.relieve (); // dummy_dc already killed by wglMakeCurrent in bind_context

    opengl_setup ();

    dc_guard.relieve ();
    rc_guard.relieve ();
  }

  GLContext::Impl::~Impl ()
  {
    wglDeleteContext (rc);
    ReleaseDC (target, dc);
  }

  GLContext::GLContext (uptr target) :
    impl (new Impl ((HWND) target))
  { }

  GLContext::~GLContext ()
  {
    delete impl;
  }

  void GLContext::flip ()
  {
    SwapBuffers (impl->dc);
  }

}
